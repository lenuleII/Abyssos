using Content.Shared.Arcade.Components;
using Content.Shared.Arcade.Enums;
using Content.Shared.Arcade.Events;
using Content.Shared.Random.Helpers;
using Robust.Shared.Prototypes;
using Robust.Shared.Random;
using Robust.Shared.Timing;

namespace Content.Shared.Arcade.Systems;

/// <summary>
///
/// </summary>
public abstract partial class SharedBlockGameArcadeSystem : EntitySystem
{
    [Dependency] private readonly IGameTiming _timing = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly SharedArcadeSystem _arcade = default!;

    /// <summary>
    ///
    /// </summary>
    public static Color Empty = new();

    public override void Initialize()
    {
        base.Initialize();

        SubscribeLocalEvent<BlockGameArcadeComponent, ComponentInit>(OnComponentInit);
        SubscribeLocalEvent<BlockGameArcadeComponent, ArcadeChangedStateEvent>(OnArcadeChangedState);
    }

    public override void Update(float frameTime)
    {
        base.Update(frameTime);

        var curTime = _timing.CurTime;
        var query = EntityQueryEnumerator<BlockGameArcadeComponent, ArcadeComponent>();
        while (query.MoveNext(out var uid, out var blockGame, out var arcade))
        {
            if (arcade.State != ArcadeGameState.Game)
                continue;

            if (blockGame.NextUpdate > curTime)
                continue;

            blockGame.NextUpdate += blockGame.UpdateCooldown;

            if (TrySpawnNextPiece((uid, blockGame)))
                continue;

            if (TryMoveFallingPieceDown((uid, blockGame)))
                TryFreezeFallingPiece((uid, blockGame));
        }
    }

    private void OnComponentInit(Entity<BlockGameArcadeComponent> ent, ref ComponentInit args)
    {
        ent.Comp.Grid = new Color[ent.Comp.GridSize.X * ent.Comp.GridSize.Y];

    }

    private void OnArcadeChangedState(Entity<BlockGameArcadeComponent> ent, ref ArcadeChangedStateEvent args)
    {
        if (args.NewState != ArcadeGameState.NewGame)
            return;

        ent.Comp.FallingPieceCells = null;
        ent.Comp.NextUpdate = _timing.CurTime + ent.Comp.UpdateCooldown;
        ent.Comp.Grid.AsSpan().Clear();
        ent.Comp.NextBagPiece = 0;

        // TODO: Use RandomPredicted https://github.com/space-wizards/RobustToolbox/pull/5849
        var seed = SharedRandomExtensions.HashCodeCombine((int)_timing.CurTick.Value, GetNetEntity(ent).Id);
        var rand = new System.Random(seed);
        RandomHelpers.Shuffle(rand, ent.Comp.PiecesBag);

        CreateUIGrid(ent);
    }

    /// <summary>
    ///
    /// </summary>
    private bool TrySpawnNextPiece(Entity<BlockGameArcadeComponent> ent)
    {
        if (ent.Comp.FallingPieceCells != null)
            return false;

        var protoId = ent.Comp.PiecesBag[ent.Comp.NextBagPiece];
        if (!_prototypeManager.TryIndex(protoId, out var fallingPiece))
        {
            Log.Error($"Invalid piece prototype {protoId} for {ToPrettyString(ent)}");
            return false;
        }

        ent.Comp.FallingPieceCells = new int[fallingPiece.Cells.Length];

        var width = ent.Comp.GridSize.X;
        var gridWidthCenter = width / 2;

        var indexLimit = ent.Comp.Grid.Length - 1;

        var color = fallingPiece.Color;

        for (var i = 0; i < fallingPiece.Cells.Length; i++)
        {
            var index = fallingPiece.Cells[i].Y * width + gridWidthCenter + fallingPiece.Cells[i].X;
            if (index < 0 || index > indexLimit)
            {
                Log.Error($"Piece {protoId} can't fit into grid of {ToPrettyString(ent)}");
                ent.Comp.FallingPieceCells = null;

                return false;
            }

            ent.Comp.FallingPieceCells[i] = index;
            ent.Comp.Grid[index] = color;

            UpdateUIGridCell(ent, index, color);
        }

        ent.Comp.FallingPieceColor = color;

        if (++ent.Comp.NextBagPiece >= ent.Comp.PiecesBag.Length - 1)
        {
            ent.Comp.NextBagPiece = 0;

            // TODO: Use RandomPredicted https://github.com/space-wizards/RobustToolbox/pull/5849
            var seed = SharedRandomExtensions.HashCodeCombine((int)_timing.CurTick.Value, GetNetEntity(ent).Id);
            var rand = new System.Random(seed);
            RandomHelpers.Shuffle(rand, ent.Comp.PiecesBag);

            //DirtyField(ent.AsNullable(), nameof(BlockGameArcadeComponent.PiecesBag));
        }

        //DirtyFields(ent.AsNullable(), null,
        //    nameof(BlockGameArcadeComponent.NextBagPiece),
        //    nameof(BlockGameArcadeComponent.FallingPieceCells),
        //    nameof(BlockGameArcadeComponent.Grid),
        //    nameof(BlockGameArcadeComponent.FallingPieceColor));

        return true;
    }

    /// <summary>
    ///
    /// </summary>
    private bool TryMoveFallingPieceDown(Entity<BlockGameArcadeComponent> ent)
    {
        if (ent.Comp.FallingPieceCells == null)
            return false;

        if (ent.Comp.FallingPieceColor == null)
            return false;

        for (var i = 0; i < ent.Comp.FallingPieceCells.Length; i++)
        {
            var index = ent.Comp.FallingPieceCells[i];
            ent.Comp.Grid[index] = Empty;
            UpdateUIGridCell(ent, index, Empty);
        }

        for (var i = 0; i < ent.Comp.FallingPieceCells.Length; i++)
        {
            var newIndex = ent.Comp.FallingPieceCells[i] + ent.Comp.GridSize.X;
            ent.Comp.Grid[newIndex] = ent.Comp.FallingPieceColor.Value;
            UpdateUIGridCell(ent, newIndex, ent.Comp.FallingPieceColor.Value);

            ent.Comp.FallingPieceCells[i] = newIndex;
        }

        // DirtyFields(ent.AsNullable(), null, nameof(BlockGameArcadeComponent.Grid), nameof(BlockGameArcadeComponent.FallingPieceCells));

        return true;
    }

    /// <summary>
    ///
    /// </summary>
    private bool TryFreezeFallingPiece(Entity<BlockGameArcadeComponent> ent)
    {
        if (ent.Comp.FallingPieceCells == null)
            return false;

        for (var i = 0; i < ent.Comp.FallingPieceCells.Length; i++)
        {
            var bottomIndex = ent.Comp.FallingPieceCells[i] + ent.Comp.GridSize.X;
            if (bottomIndex >= ent.Comp.Grid.Length || (ent.Comp.Grid[bottomIndex] != Empty && !ent.Comp.FallingPieceCells.Contains(bottomIndex)))
            {
                ent.Comp.FallingPieceCells = null;
                ent.Comp.FallingPieceColor = null;

                // DirtyFields(ent.AsNullable(), null, nameof(BlockGameArcadeComponent.FallingPieceCells), nameof(BlockGameArcadeComponent.FallingPieceColor));

                return true;
            }
        }

        return false;
    }

    /// <summary>
    ///
    /// </summary>
    private bool TryShiftRowDown(Entity<BlockGameArcadeComponent> ent, int y)
    {
        if (y < 1 || y >= ent.Comp.GridSize.Y - 1)
            return false;

        // Check if destination row is empty
        var dstRowStart = (y + 1) * ent.Comp.GridSize.X;
        for (var x = 0; x < ent.Comp.GridSize.X; x++)
        {
            if (ent.Comp.Grid[dstRowStart + x] != Empty)
                return false;
        }

        var srcRowStart = y * ent.Comp.GridSize.X;

        var moved = false;
        for (var x = 0; x < ent.Comp.GridSize.X; x++)
        {
            var srcIndex = srcRowStart + x;
            if (ent.Comp.Grid[srcIndex] == Empty)
                continue;

            var color = ent.Comp.Grid[srcIndex];
            var dstIndex = dstRowStart + x;

            ent.Comp.Grid[dstIndex] = color;
            ent.Comp.Grid[srcIndex] = Empty;

            UpdateUIGridCell(ent, dstIndex, color);
            UpdateUIGridCell(ent, srcIndex, Empty);

            moved = true;
        }

        //if (moved)
        //    DirtyField(ent.AsNullable(), nameof(BlockGameArcadeComponent.Grid));

        return moved;
    }

    /// <summary>
    ///
    /// </summary>
    protected virtual void CreateUIGrid(Entity<BlockGameArcadeComponent> ent) { }

    /// <summary>
    ///
    /// </summary>
    protected virtual void UpdateUIGridCell(Entity<BlockGameArcadeComponent> ent, int index, Color newColor) { }
}
